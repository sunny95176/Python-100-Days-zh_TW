## 那些年我們踩過的那些坑

### 坑1 - 整數比較的坑

在 Python 中一切都是物件，整數也是物件，在比較兩個整數時有兩個運算子`==`和`is`，它們的區別是：

- `is`比較的是兩個整數物件的id值是否相等，也就是比較兩個引用是否代表了記憶體中同一個地址。
- `==`比較的是兩個整數物件的內容是否相等，使用`==`時其實是呼叫了物件的`__eq__()`方法。

知道了`is`和`==`的區別之後，我們可以來看看下面的程式碼，瞭解Python中整數比較有哪些坑，**以CPython直譯器為例**，大家先看看下面的程式碼。

```Python
def main():
	x = y = -1
	while True:
		x += 1
		y += 1
		if x is y:
			print('%d is %d' % (x, y))
		else:
			print('Attention! %d is not %d' % (x, y))
			break
			
	x = y = 0
	while True:
		x -= 1
		y -= 1
		if x is y:
			print('%d is %d' % (x, y))
		else:
			print('Attention! %d is not %d' % (x, y))
			break


if __name__ == '__main__':
	main()
```

上面程式碼的部分執行結果如下圖所示。這個結果是因為CPython出於效能最佳化的考慮，把頻繁使用的整數物件用一個叫`small_ints`的物件池快取起來造成的。`small_ints`快取的整數值被設定為`[-5, 256]`這個區間，也就是說，如果使用CPython直譯器，在任何引用這些整數的地方，都不需要重新建立`int`物件，而是直接引用快取池中的物件。如果整數不在該範圍內，那麼即便兩個整數的值相同，它們也是不同的物件。

![](./res/int-is-comparation.png)

當然僅僅如此這個坑就不值一提了，如果你理解了上面的規則，我們就再看看下面的程式碼。

```Python
a = 257


def main():
	b = 257  # 第6行
	c = 257  # 第7行
	print(b is c)  # True
	print(a is b)  # False
	print(a is c)  # False


if __name__ == "__main__":
	main()
```

程式的執行結果已經用註釋寫在程式碼上了。夠坑吧！看上去`a`、`b`和`c`的值都是一樣的，但是`is`運算的結果卻不一樣。為什麼會出現這樣的結果，首先我們來說說Python程式中的程式碼塊。所謂程式碼塊是程式的一個最小的基本執行單位，一個模組檔案、一個函式體、一個類、互動式命令中的單行程式碼都叫做一個程式碼塊。上面的程式碼由兩個程式碼塊構成，`a = 257`是一個程式碼塊，`main`函式是另外一個程式碼塊。CPython底層為了進一步提升效能還做了一個設定：對於同一個程式碼塊中值不在`small_ints`快取範圍之內的整數，如果同一個程式碼塊中已經存在一個值與其相同的整數物件，那麼就直接引用該物件，否則建立新的`int`物件。需要大家注意的是，這條規則對數值型適用，但對字串則需要考慮字串的長度，這一點可以自行證明。
為了驗證剛剛的結論，我們可以借用`dis`模組（聽名字就知道是進行反彙編的模組）從位元組碼的角度來看看這段程式碼。如果不理解什麼是位元組碼，可以先看看[《談談 Python 程式的執行原理》]((http://www.cnblogs.com/restran/p/4903056.html))這篇文章。可以先用`import dis`匯入`dis`模組並按照如下所示的方式修改程式碼。

```Python
import dis

dis.dis(main)
```

程式碼的執行結果如下圖所示。可以看出程式碼第6行和第7行，也就是`main`函式中的257是從同一個位置載入的，因此是同一個物件；而程式碼第9行的`a`明顯是從不同的地方載入的，因此引用的是不同的物件。

![](./res/result-of-dis.png)

如果還想對這個問題進行進一步深挖，推薦大家閱讀[《Python整數物件實現原理》](https://foofish.net/python_int_implement.html)這篇文章。

### 坑2 - 巢狀列表的坑

Python中有一種內建的資料型別叫列表，它是一種容器，可以用來承載其他的物件（準確的說是其他物件的引用），列表中的物件可以稱為列表的元素，很明顯我們可以把列表作為列表中的元素，這就是所謂的巢狀列表。巢狀列表可以模擬出現實中的表格、矩陣、2D遊戲的地圖（如植物大戰殭屍的花園）、棋盤（如國際象棋、黑白棋）等。但是在使用巢狀的列表時要小心，否則很可能遭遇非常尷尬的情況，下面是一個小例子。

```Python
names = ['關羽', '張飛', '趙雲', '馬超', '黃忠']
subjs = ['語文', '數學', '英語']
scores = [[0] * 3] * 5
for row, name in enumerate(names):
    print('請輸入%s的成績' % name)
    for col, subj in enumerate(subjs):
        scores[row][col] = float(input(subj + ': '))
        print(scores)
```

我們希望錄入5個學生3門課程的成績，於是定義了一個有5個元素的列表，而列表中的每個元素又是一個由3個元素構成的列表，這樣一個列表的列表剛好跟一個表格是一致的，相當於有5行3列，接下來我們透過巢狀的for-in迴圈輸入每個學生3門課程的成績。程式執行完成後我們發現，每個學生3門課程的成績是一模一樣的，而且就是最後錄入的那個學生的成績。

要想把這個坑填平，我們首先要區分物件和物件的引用這兩個概念，而要區分這兩個概念，還得先說說記憶體中的棧和堆。我們經常會聽人說起“堆疊”這個詞，但實際上“堆”和“棧”是兩個不同的概念。眾所周知，一個程式執行時需要佔用一些記憶體空間來儲存資料和程式碼，那麼這些記憶體從邏輯上又可以做進一步的劃分。對底層語言（如C語言）有所瞭解的程式設計師大都知道，程式中可以使用的記憶體從邏輯上可以為五個部分，按照地址從高到低依次是：棧（stack）、堆（heap）、資料段（data segment）、只讀資料段（static area）和程式碼段（code segment）。其中，棧用來儲存區域性、臨時變數，以及函式呼叫時儲存現場和恢復現場需要用到的資料，這部分記憶體在程式碼塊開始執行時自動分配，程式碼塊執行結束時自動釋放，通常由編譯器自動管理；堆的大小不固定，可以動態的分配和回收，因此如果程式中有大量的資料需要處理，這些資料通常都放在堆上，如果堆空間沒有正確的被釋放會引發記憶體洩露的問題，而像Python、Java等程式語言都使用了垃圾回收機制來實現自動化的記憶體管理（自動回收不再使用的堆空間）。所以下面的程式碼中，變數`a`並不是真正的物件，它是物件的引用，相當於記錄了物件在堆空間的地址，透過這個地址我們可以訪問到對應的物件；同理，變數`b`是列表容器的引用，它引用了堆空間上的列表容器，而列表容器中並沒有儲存真正的物件，它儲存的也僅僅是物件的引用。

 ```Python
a = object()
b = ['apple', 'pitaya', 'grape']
 ```

知道了這一點，我們可以回過頭看看剛才的程式，我們對列表進行`[[0] * 3] * 5`操作時，僅僅是將`[0, 0, 0]`這個列表的地址進行了複製，並沒有建立新的列表物件，所以容器中雖然有5個元素，但是這5個元素引用了同一個列表物件，這一點可以透過`id`函式檢查`scores[0]`和`scores[1]`的地址得到證實。所以正確的程式碼應該按照如下的方式進行修改。

```Python
names = ['關羽', '張飛', '趙雲', '馬超', '黃忠']
subjs = ['語文', '數學', '英語']
scores = [[]] * 5
for row, name in enumerate(names):
    print('請輸入%s的成績' % name)
    scores[row] = [0] * 3
    for col, subj in enumerate(subjs):
        scores[row][col] = float(input(subj + ': '))
        print(scores)
```

或者

```Python
names = ['關羽', '張飛', '趙雲', '馬超', '黃忠']
subjs = ['語文', '數學', '英語']
scores = [[0] * 3 for _ in range(5)]
for row, name in enumerate(names):
    print('請輸入%s的成績' % name)
    scores[row] = [0] * 3
    for col, subj in enumerate(subjs):
        scores[row][col] = float(input(subj + ': '))
        print(scores)
```

如果對記憶體的使用不是很理解，可以看看[PythonTutor網站](http://www.pythontutor.com/)上提供的程式碼視覺化執行功能，透過視覺化執行，我們可以看到記憶體是如何分配的，從而避免在使用巢狀列表或者複製物件時可能遇到的坑。

![](./res/python-tutor-visualize.png)

![](./res/python-tutor-visualize2.png)

### 坑3 - 訪問修飾符的坑

用Python做過面向物件程式設計的人都知道，Python的類提供了兩種訪問控制權限，一種是公開，一種是私有（在屬性或方法前加上雙下劃線）。而用慣了Java或C#這類程式語言的人都知道，類中的屬性（資料抽象）通常都是私有的，其目的是為了將資料保護起來；而類中的方法（行為抽象）通常都是公開的，因為方法是物件向外界提供的服務。但是Python並沒有從語法層面確保私有成員的私密性，因為它只是對類中所謂的私有成員進行了命名的變換，如果知道命名的規則照樣可以直接訪問私有成員，請看下面的程式碼。

```Python
class Student(object):

    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def __str__(self):
        return self.__name + ': ' + str(self.__age)


stu = Student('駱昊', 38)
print(stu._Student__name)
print(stu._Student__age)
```

Python為什麼要做出這樣的設定呢？用一句廣為流傳的格言來解釋這個問題：“We are all consenting adults here”（我們都是成年人）。這句話表達了很多Python程式設計師的一個共同觀點，那就是開放比封閉要好，我們應該自己對自己的行為負責而不是從語言層面來限制對資料或方法的訪問。

所以在Python中我們實在沒有必要將類中的屬性或方法用雙下劃線開頭的命名處理成私有的成員，因為這並沒有任何實際的意義。如果想對屬性或方法進行保護，我們建議用單下劃線開頭的受保護成員，雖然它也不能真正保護這些屬性或方法，但是它相當於給呼叫者一個暗示，讓呼叫者知道這是不應該直接訪問的屬性或方法，而且這樣做並不影響子類去繼承這些東西。

需要提醒大家注意的是，Python類中的那些魔法方法，如`__str__`、`__repr__`等，這些方法並不是私有成員哦，雖然它們以雙下劃線開頭，但是他們也是以雙下劃線結尾的，這種命名並不是私有成員的命名，這一點對初學者來說真的很坑。

